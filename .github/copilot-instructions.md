# James Games - AI Coding Guidelines

## Project Overview

Mobile-first web game hub built with React + Vite and Phaser 3. The player-facing app now lives in `apps/player-web/`, and each game is self-contained in `apps/player-web/src/games/[gameId]/` with dynamic mounting. React handles routing, UI, and cross-game state; Phaser manages game logic and rendering. Games communicate via custom events (`apps/player-web/src/utils/gameEvents.ts`).

## Architecture

- **Frontend**: React functional components with hooks housed in `apps/player-web/`, Tailwind CSS for styling, no class components.
- **Games**: Phaser 3 scenes extended from `Phaser.Scene`. Each game exports a `mount(container)` function creating a `Phaser.Game` instance.
- **Integration**: Games dispatch events (e.g., `dispatchGameOver`) for React to show dialogs. No global state management yet (Redux planned but unused).
- **Backend**: Minimal API via `apps/backend-api/src` (Express on Lambda). Player web app talks to it through helpers in `apps/player-web/src/lib/api.ts`.
- **Admin**: Placeholder React shell under `apps/admin-web/` reserved for future operational tooling.

## Key Patterns

- **Phaser Config** (see `apps/player-web/src/games/reflex-ring/index.ts`):
  ```typescript
  const config = {
    type: Phaser.AUTO,
    width: 540,
    height: 960,
    parent: container,
    transparent: true,
    scale: {
      mode: Phaser.Scale.FIT,
      autoCenter: Phaser.Scale.CENTER_BOTH,
      width: 540,
      height: 960,
    },
    scene: [ReflexRingGame],
  };
  ```
- **Mounting Games**: Phaser.Game with parent container, destroy via game.destroy(true).
- **Input**: Use `pointerdown` for touch/mobile (not `click`).
- **Analytics**: gtag-based (`apps/player-web/src/utils/analytics.ts`), events like `game_start` fired on mount.
- **Assets**: Static in `apps/player-web/public/assets/[gameId]/`, loaded relatively.
- **Sounds**: Synthesized Web Audio API (oscillators/gains), no audio files.

## Development Workflow

- **Dev**: `npm run web:dev` (Vite with custom config located in `apps/player-web/vite`).
- **Build**: `npm run web:build` (produces a PWA-ready bundle under `apps/player-web/dist`).
- **Game Creation**: Copy existing game folder, update `apps/player-web/src/games/index.ts` with lazy import.
- **Testing**: Manual playtesting; no automated tests yet.

## Conventions

Adhere strictly to the following best practices when generating, refactoring, or extending Phaser 3 game code. These guidelines prioritize code organization, performance, maintainability, and testing efficiency.

1. Code Organization & Project Structure
   Modularity First: Use modern ES6 modules (import/export) for all code organization. Avoid global scope pollution.
   Scene-Based Architecture:
   Every distinct game state must be a class extending Phaser.Scene (e.g., BootScene, PreloadScene, MainMenuScene, GameScene).
   Each scene class must reside in its own dedicated file.
   Decoupled Logic: Input handling (keyboard, pointer) must be handled at the Scene level or by a dedicated input manager plugin, not inside individual game objects (like Player or Enemy sprites).
   Asset & Config Constants:
   Use a centralized constants.js or config.js file for all asset keys, paths, magic numbers, and configuration strings.
   Always reference these constants (Config.ASSET_KEYS.PLAYER_SHIP) rather than using raw strings ('player-ship').
   Component-Based Design: For complex systems (like inventory, stats, or specific behaviors), use a simple Entity Component System (ECS) pattern or composition over inheritance where applicable.
2. Performance Best Practices
   Minimize Draw Calls:
   Utilize texture atlases/sprite sheets generated by a texture packer for related assets.
   Prefer Tilemaps over individually placed sprites for static level geometry.
   Efficient Memory Management:
   Implement Object Pooling for highly dynamic, frequently created/destroyed objects (bullets, explosions, enemies). Recycle objects instead of creating new instances constantly to minimize garbage collection pauses.
   Optimize update() Loops: Keep the core update(time, delta) methods in scenes and objects lean. Delegate complex logic to external systems or state machines that run conditionally.
   Cache References: Store local references to frequently accessed objects, configurations, and game systems (this.player = ...) rather than looking them up dynamically every frame.
3. Naming Conventions & Style
   Classes: Use PascalCase (e.g., PlayerShip, BootScene).
   Variables/Functions: Use camelCase (e.g., playerScore, handleInput()).
   Constants: Use UPPER_SNAKE_CASE (e.g., MAX_SPEED, PLAYER_ATLAS_KEY).
   Clarity over Brevity: Variable and function names should clearly describe their purpose (e.g., calculateDamage() instead of calcDmg()).
4. Testing & Debugging (When Applicable)
   Testable Units: Write logic functions to be side-effect-free where possible, making them easier to unit test independently of the Phaser rendering engine.
   Phaser Debug Tools: Use built-in Phaser debug features (e.g., this.physics.world.debugGraphic) rather than relying solely on console.log() for physics debugging.

## Creating a New Game

To create a new game within the James Games framework, follow these steps:

1. **Set up folder**: Create a new game folder in `apps/player-web/src/games/`.
2. **Update Phaser scene**: Modify `create()`, `update()` for gameplay. Use `Phaser.Scene` extension, `pointerdown` for input, tweens/animations for effects.
3. **Implement mount**: In `index.ts`, export `mount(container)` creating `Phaser.Game` with FIT scale (see reflex-ring example).
4. **Add thumbnail**: Create `thumbnail.svg` in `apps/player-web/public/assets/[newId]/` for game listings. Make sure this is a lightweight SVG optimized for web and does not contain any text.
5. **Register game**: Add entry to `apps/player-web/src/games/index.ts` with lazy import (e.g., `load: async () => import("./[newId]/index")`).
6. **Utilize shared systems**:
   - **Score tracking**: Use localStorage for high scores (`localStorage.getItem/setItem` with `${GAME_ID}-best`).
   - **Game over**: Call `dispatchGameOver({ gameId: GAME_ID, score })` to trigger GameOver dialog.
   - **Analytics**: Call `trackGameStart(gameId, title)` on mount.
   - **Backend**: Use `postHighScore` from `apps/player-web/src/lib/api.ts` for score submission.
   - **Experience**: XP is calculated based on score Ã— game-specific multiplier (stored in game metadata).
   - **Sounds**: Synthesize via Web Audio API (oscillators/gains) for effects like pop/ding.
   - **Particles**: Use Phaser particles for backgrounds/effects.
7. **Incorporate shared components**: Games integrate with React via events; GameOver dialog handles post-game UI automatically.
8. **Patterns to follow**: Touch-optimized, 60 FPS, portrait mode, modular scenes, commented logic. Test on mobile, ensure no global state.

Prioritize mobile performance, simplicity, and Phaser best practices. Reference existing games for new ones.

When making changes to game logic, update the `updatedAt` field in the corresponding game entry in `apps/player-web/src/games/index.ts`.

## Reusable prefabs and utilities

When creating new games, consider leveraging the following reusable prefabs and utilities available in the codebase to streamline development:

- **PlayerPrefab**: A base class for player-controlled sprites with built-in movement and input handling.
- **EnemyPrefab**: A base class for enemy sprites with common behaviors like movement patterns and collision handling.
- **UI Components**: Pre-built Phaser UI elements such as buttons, score displays, and health bars.
- **GameEvents**: Utility functions for dispatching and listening to custom game events to facilitate communication between Phaser and React.
- **AudioManager**: A utility for managing sound effects and music using the Web Audio API.
- **ParticleEffects**: Pre-configured particle emitters for common visual effects like explosions and trails.
- **InputManager**: A centralized input handling utility to manage touch and pointer events across different scenes.
- **ScoreManager**: A utility for tracking and storing high scores using localStorage.
- **Analytics**: Functions for tracking game events and user interactions with Google Analytics (gtag).
  Utilizing these prefabs and utilities can help maintain consistency across games, reduce development time, and ensure adherence to best practices outlined in this document.
