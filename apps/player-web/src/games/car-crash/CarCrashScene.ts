import Phaser from "phaser";
import { dispatchGameOver } from "../../utils/gameEvents";

const GAME_ID = "car-crash";
const STORAGE_BEST_KEY = `${GAME_ID}-best`;

// Logical portrait game size used for config; scene scales to fit like other games
// const LOGICAL_WIDTH = 540;
// const LOGICAL_HEIGHT = 960;

// Step-based world updates (variable interval with optional decay)
const STEP_INTERVAL_START_MS = 500; // starting step interval in ms
const STEP_INTERVAL_MIN_MS = 260; // floor for step interval (faster => smaller)
const STEP_DECAY_PER_TICK = 0.997; // multiply interval each tick (1.0 disables decay)
let STEP_PIXELS = 28; // increases over time

// Lanes
const LANE_COUNT = 3;
const ROAD_WIDTH_RATIO = 0.76; // portion of width used by road
const LANE_SEPARATOR_WIDTH = 6;

// Player/obstacles
const PLAYER_CAR_WIDTH_RATIO = 0.18; // slightly smaller
const OB_CAR_WIDTH_RATIO = 0.18;
const CAR_VERTICAL_SCALE = 0.85; // shorten cars visually (not as long)
const HITBOX_SCALE_X = 0.85; // shrink hitbox width for fairness
const HITBOX_SCALE_Y = 0.7; // shrink hitbox height to avoid edge collisions in gaps

// Spawning/difficulty (spawns aligned with step ticks)

// UI buttons
const BTN_RADIUS = 56;

export default class CarCrashScene extends Phaser.Scene {
  private roadLeftX = 0;
  private roadRightX = 0;
  private laneCenters: number[] = [];

  private player!: Phaser.Physics.Arcade.Sprite;
  private playerLane = 1; // 0..2
  private playerY = 0;

  private obstacles!: Phaser.Physics.Arcade.Group;
  private score = 0;
  private best = 0;
  private scoreText!: Phaser.GameObjects.Text;

  // Row spawning constraints
  private maxCarsPerRow = 1; // starts at 1, can increase to 2 later
  private gapTicksRemaining = 0; // enforce empty ticks between rows

  // Difficulty ramping
  private desiredTicksVisible = 7; // cars visible from spawn to player for ~N ticks; decreases over time to speed up
  private diffAccMs = 0;
  private difficultyLevel = 0;
  private stripeSpeedFactor = 1.4; // make lane dashes move a bit faster than cars for better motion feel
  private gapSafetyMultiplier = 1.35; // gaps are taller than car sprites to avoid visual overlaps

  // Grid system (one row per tick)
  private gridSizeY = STEP_PIXELS; // pixels per row (advances one row per tick)
  private gridOffsetY = 0; // pixel offset so player centers on a grid row
  // Tick accumulators (use update loop instead of timers to avoid jitter/frame pauses)
  private stepAcc = 0;
  private stepIntervalMs = STEP_INTERVAL_START_MS;
  // Acceleration timer disabled; pacing kept constant for 7-tick visibility

  private stripes!: Phaser.GameObjects.TileSprite[]; // dashed lane separators

  private gameOver = false;

  constructor() {
    super(GAME_ID);
  }

  preload() {
    // Cars PNGs generated by scripts/generate-car-crash-assets.mjs
    this.load.image("playerCar", "/assets/car-crash/player.png");
    this.load.image("obCar1", "/assets/car-crash/car1.png");
    this.load.image("obCar2", "/assets/car-crash/car2.png");
    // Arrow icons for buttons (simple triangle textures)
    this.createArrowTexture("uiLeft", true);
    this.createArrowTexture("uiRight", false);
    // Dashed texture for lane separators
    this.makeLaneDashTexture();
  }

  create() {
    const { width, height } = this.scale;

    // Road layout
    const roadWidth = Math.floor(width * ROAD_WIDTH_RATIO);
    this.roadLeftX = Math.floor((width - roadWidth) / 2);
    this.roadRightX = this.roadLeftX + roadWidth;

    // Grass areas
    this.add.rectangle(this.roadLeftX / 2, height / 2, this.roadLeftX, height, 0x2e7d32);
    this.add.rectangle(
      (this.roadRightX + width) / 2,
      height / 2,
      width - this.roadRightX,
      height,
      0x2e7d32
    );

    // Road background
    this.add.rectangle(width / 2, height / 2, roadWidth, height, 0x4b4b4b);

    // Lane centers (3 lanes)
    const laneWidth = roadWidth / LANE_COUNT;
    this.laneCenters = [0, 1, 2].map((i) => this.roadLeftX + laneWidth * (i + 0.5));

    // Dashed white lines between lanes using TileSprites for a step illusion
    this.stripes = [];
    for (let i = 1; i < LANE_COUNT; i++) {
      const x = this.roadLeftX + laneWidth * i;
      const stripe = this.add.tileSprite(x, height / 2, LANE_SEPARATOR_WIDTH, height, "laneDash");
      stripe.setTint(0xffffff);
      stripe.setAlpha(0.9);
      this.stripes.push(stripe);
    }

    // Physics
    this.physics.world.setBounds(this.roadLeftX, 0, roadWidth, height);

    // Player
    const playerTex = "playerCar";
    const playerW = width * PLAYER_CAR_WIDTH_RATIO;
    this.player = this.physics.add.sprite(this.laneCenters[this.playerLane], 0, playerTex);
    const pScale = playerW / this.player.width;
    this.player.setScale(pScale, pScale * CAR_VERTICAL_SCALE);
    this.playerY = Math.floor(height * 0.78);
    this.player.setY(this.playerY);
    this.player.setImmovable(true);
    this.player.setDepth(10);
    // Soften collisions: slightly smaller player hitbox, centered
    if (this.player.body) {
      this.player.body.setSize(
        this.player.displayWidth * HITBOX_SCALE_X,
        this.player.displayHeight * HITBOX_SCALE_Y,
        true
      );
    }

    // Obstacles group
    this.obstacles = this.physics.add.group();

    // Weâ€™ll handle collisions logically by grid row/lane match after each tick

    // Score UI
    this.best = Number(localStorage.getItem(STORAGE_BEST_KEY) || 0);
    this.scoreText = this.add
      .text(16, 12, this.makeScoreText(), {
        fontFamily: "Fredoka, Arial Black, Arial, sans-serif",
        fontSize: "28px",
        color: "#ffffff",
        stroke: "#000",
        strokeThickness: 6,
      })
      .setDepth(20);

    // Controls: buttons + keyboard
    this.addUIButtons();
    this.addKeyboard();

    // Calibrate step so each car is visible for ~desiredTicksVisible from spawn to the player
    this.recalcStepPixels();
    // Initialize grid aligned to player position
    this.gridSizeY = STEP_PIXELS;
    this.gridOffsetY = this.playerY % this.gridSizeY;
    // Snap player to nearest grid row center
    const pr = this.getRowIndexForY(this.playerY);
    this.playerY = this.getRowCenterY(pr);
    this.player.setY(this.playerY);

    // Initialize accumulators
    this.stepAcc = 0;
    this.stepIntervalMs = STEP_INTERVAL_START_MS;
    // Difficulty state
    this.diffAccMs = 0;
    this.difficultyLevel = 0;
  }

  update(_t: number, dt: number) {
    if (this.gameOver) return;
    this.stepAcc += dt;
    this.diffAccMs += dt;

    // Advance world in discrete steps
    while (this.stepAcc >= this.stepIntervalMs) {
      this.stepAcc -= this.stepIntervalMs;
      // One game tick: move world, spawn attempt, ramp difficulty, decay interval
      this.stepWorld();
      this.spawnRow();
      this.maybeIncreaseDifficulty();
      // Decay step interval slightly (speed up) each tick
      this.stepIntervalMs = Math.max(
        STEP_INTERVAL_MIN_MS,
        this.stepIntervalMs * STEP_DECAY_PER_TICK
      );
    }
  }

  private stepWorld() {
    if (this.gameOver) return;

    // Move obstacles down by STEP_PIXELS; destroy if off-screen; score when passed player
    const h = this.scale.height;
    const children = this.obstacles.getChildren().slice(); // snapshot to avoid mutation during iteration
    for (const obj of children) {
      const o = obj as Phaser.Physics.Arcade.Sprite & { counted?: boolean };
      if (!o.active) continue;
      o.y += STEP_PIXELS;
      // Snap to grid center to avoid drift
      const ri = this.getRowIndexForY(o.y);
      o.y = this.getRowCenterY(ri);
    }
    // Destroy off-screen in a separate pass to avoid skipping updates
    for (const obj of children) {
      const o = obj as Phaser.Physics.Arcade.Sprite & { counted?: boolean };
      if (!o.active) continue;
      if (o.y > h + this.gridSizeY * 2) {
        o.destroy();
      }
    }

    // Grid-based scoring and collisions: if any car shares player's row and lane -> crash
    const playerRow = this.getRowIndexForY(this.playerY);
    const playerLaneX = this.laneCenters[this.playerLane];
    for (const obj of this.obstacles.getChildren()) {
      const o = obj as Phaser.Physics.Arcade.Sprite & { counted?: boolean };
      if (!o.active) continue;
      const ri = this.getRowIndexForY(o.y);
      // Score when car rows move strictly below player row for the first time
      if (!o.counted && ri > playerRow) {
        o.counted = true;
        this.score += 1;
        this.scoreText.setText(this.makeScoreText());
      }
      // Crash only when lane matches AND same row
      if (Math.abs(o.x - playerLaneX) < 2 && ri === playerRow) {
        this.onCrash();
        break;
      }
    }

    // Move lane dashes in lockstep with the world tick (no tweening)
    this.stripes.forEach((s) => {
      s.tilePositionY -= STEP_PIXELS * this.stripeSpeedFactor; // a bit faster than cars
    });
  }

  private spawnRow() {
    if (this.gameOver) return;
    const { width } = this.scale;

    // Always insert gap ticks before the next line of cars
    if (this.gapTicksRemaining > 0) {
      this.gapTicksRemaining -= 1; // consume one empty tick
      return;
    }

    // Choose 1 or 2 lanes to guarantee at least 1 gap
    const lanes = [0, 1, 2].sort(() => Math.random() - 0.5);
    const desired = Math.min(2, Math.max(1, this.maxCarsPerRow)); // never more than 2 lanes in a row
    const chosen = lanes.slice(0, desired);

    // Compute display height for spacing checks using the tallest obstacle texture
    const tex1 = this.textures.get("obCar1");
    const tex2 = this.textures.get("obCar2");
    const img1 = (tex1 && (tex1.getSourceImage() as HTMLImageElement)) || undefined;
    const img2 = (tex2 && (tex2.getSourceImage() as HTMLImageElement)) || undefined;
    const baseW = Math.max(img1?.width || 220, img2?.width || 220);
    const baseH = Math.max(img1?.height || 360, img2?.height || 360);
    const scaleX = (width * OB_CAR_WIDTH_RATIO) / baseW;
    const displayH = baseH * scaleX * CAR_VERTICAL_SCALE;
    const minLaneSpacing = Math.max(displayH * 1.25, STEP_PIXELS * 1.2);

    let spawned = 0;
    chosen.forEach((lane) => {
      // Align spawn to the top grid row just above the screen
      const topRow = Math.ceil((0 - this.gridOffsetY) / this.gridSizeY) - 1;
      const spawnY = this.getRowCenterY(topRow);
      if (!this.canSpawnInLane(lane, spawnY, minLaneSpacing)) return;
      const tex = Math.random() < 0.5 ? "obCar1" : "obCar2";
      const x = this.laneCenters[lane];
      const y = spawnY; // grid-aligned spawn
      const ob = this.obstacles.create(x, y, tex) as Phaser.Physics.Arcade.Sprite & {
        counted?: boolean;
      };
      ob.setScale(scaleX, scaleX * CAR_VERTICAL_SCALE);
      ob.setDepth(5);
      (ob as any).counted = false;
      // Soften collisions: slightly smaller obstacle hitbox, centered
      if (ob.body) {
        ob.body.setSize(ob.displayWidth * HITBOX_SCALE_X, ob.displayHeight * HITBOX_SCALE_Y, true);
      }
      spawned += 1;
    });

    // After a row (if any car spawned), enforce a gap row next tick
    if (spawned > 0) this.gapTicksRemaining = this.computeEqualGapTicks(displayH);

    // Simple ramp: once the player scores enough, allow up to 2 cars per row
    if (this.score >= 10) this.maxCarsPerRow = 2;
  }

  private canSpawnInLane(lane: number, y: number, minSpacing: number) {
    let ok = true;
    const laneX = this.laneCenters[lane];
    this.obstacles.getChildren().forEach((obj) => {
      const o = obj as Phaser.Physics.Arcade.Sprite;
      if (Math.abs(o.x - laneX) < 2) {
        if (Math.abs(o.y - y) < minSpacing) {
          ok = false;
        }
      }
    });
    return ok;
  }

  // Difficulty increases disabled to maintain consistent 7-tick visibility pacing

  private addUIButtons() {
    const { width, height } = this.scale;

    const makeBtn = (x: number, y: number, key: string, handler: () => void) => {
      const c = this.add.container(x, y).setDepth(30);
      const bg = this.add.circle(0, 0, BTN_RADIUS, 0xffffff, 0.12).setStrokeStyle(3, 0xffffff, 0.6);
      const icon = this.add.image(0, 0, key).setScale(0.9).setTint(0xffffff).setAlpha(0.9);
      c.add([bg, icon]);
      c.setSize(BTN_RADIUS * 2, BTN_RADIUS * 2);
      c.setInteractive(new Phaser.Geom.Circle(0, 0, BTN_RADIUS), Phaser.Geom.Circle.Contains);
      c.on("pointerdown", () => {
        (bg as Phaser.GameObjects.Arc).setFillStyle(0xffffff, 0.25);
        handler();
      });
      c.on("pointerup", () => (bg as Phaser.GameObjects.Arc).setFillStyle(0xffffff, 0.12));
      c.on("pointerout", () => (bg as Phaser.GameObjects.Arc).setFillStyle(0xffffff, 0.12));
      return c;
    };

    const pad = 24;
    makeBtn(pad + BTN_RADIUS, height - (pad + BTN_RADIUS), "uiLeft", () => this.moveLeft());
    makeBtn(width - (pad + BTN_RADIUS), height - (pad + BTN_RADIUS), "uiRight", () =>
      this.moveRight()
    );

    // Large invisible hit zones for easier taps: left/right halves of the screen
    // They sit behind the visible buttons (lower depth) and only trigger outside the button area
    const leftZone = this.add
      .zone(width * 0.25, height * 0.5, width * 0.5, height)
      .setDepth(5)
      .setInteractive();
    leftZone.on("pointerdown", () => this.moveLeft());

    const rightZone = this.add
      .zone(width * 0.75, height * 0.5, width * 0.5, height)
      .setDepth(5)
      .setInteractive();
    rightZone.on("pointerdown", () => this.moveRight());
  }

  private addKeyboard() {
    const keys = this.input.keyboard!.addKeys({
      left: Phaser.Input.Keyboard.KeyCodes.LEFT,
      right: Phaser.Input.Keyboard.KeyCodes.RIGHT,
    }) as any;
    keys.left.on("down", () => this.moveLeft());
    keys.right.on("down", () => this.moveRight());
  }

  private moveLeft() {
    if (this.gameOver) return;
    this.setLane(this.playerLane - 1);
  }

  private moveRight() {
    if (this.gameOver) return;
    this.setLane(this.playerLane + 1);
  }

  private setLane(idx: number) {
    const clamped = Phaser.Math.Clamp(idx, 0, LANE_COUNT - 1);
    if (clamped === this.playerLane) return;
    // Immediate collision check when attempting to enter a new grid cell (lane,row)
    if (this.checkImmediateCollisionAtLane(clamped)) {
      // Crash synchronously; do not move
      return;
    }
    this.playerLane = clamped;
    const x = this.laneCenters[clamped];
    this.tweens.add({ targets: this.player, x, duration: 120, ease: "Quad.Out" });
  }

  private onCrash() {
    if (this.gameOver) return;
    this.gameOver = true;

    // Best (local)
    if (this.score > this.best) {
      this.best = this.score;
      localStorage.setItem(STORAGE_BEST_KEY, String(this.best));
    }

    // Score posting now centralized in ScoreDialog (triggered via dispatchGameOver)

    // Screen effect
    this.cameras.main.shake(250, 0.01);
    this.cameras.main.flash(120, 255, 50, 50);

    const w = this.scale.width,
      h = this.scale.height;
    const overlay = this.add.rectangle(w / 2, h / 2, w, h, 0x000000, 0.55).setDepth(50);
    const t1 = this.add
      .text(w / 2, h / 2 - 20, "Crash!", {
        fontFamily: "Arial Black",
        fontSize: "42px",
        color: "#fff",
        stroke: "#000",
        strokeThickness: 6,
      })
      .setOrigin(0.5)
      .setDepth(50);
    const t2 = this.add
      .text(w / 2, h / 2 + 30, "Tap to Restart", {
        fontFamily: "Arial",
        fontSize: "22px",
        color: "#fff",
      })
      .setOrigin(0.5)
      .setDepth(50);

    // Notify shell
    try {
      dispatchGameOver({ gameId: GAME_ID, score: this.score, ts: Date.now() });
    } catch {}

    this.time.delayedCall(900, () => {
      this.input.once("pointerdown", () => {
        overlay.destroy();
        t1.destroy();
        t2.destroy();
        this.restart();
      });
    });
  }

  private restart() {
    // Reset state
    this.gameOver = false;
    this.score = 0;
    this.scoreText.setText(this.makeScoreText());
    this.maxCarsPerRow = 1;
    this.gapTicksRemaining = 0;
    this.desiredTicksVisible = 7;
    this.difficultyLevel = 0;
    this.stripeSpeedFactor = 1.4;

    // Reset pacing (recompute for ~7 ticks visibility)
    this.recalcStepPixels();
    // Reset grid alignment
    this.gridSizeY = STEP_PIXELS;
    this.gridOffsetY = this.playerY % this.gridSizeY;
    const pr = this.getRowIndexForY(this.playerY);
    this.playerY = this.getRowCenterY(pr);
    this.player.setY(this.playerY);
    this.stepIntervalMs = STEP_INTERVAL_START_MS;
    this.stepAcc = 0;

    // Clear obstacles
    this.obstacles.clear(true, true);

    // Reset player to center lane
    this.playerLane = 1;
    this.player.x = this.laneCenters[this.playerLane];
  }

  // Helpers
  private makeScoreText() {
    return `Score: ${this.score}   Best: ${this.best}`;
  }

  private createArrowTexture(key: string, left: boolean) {
    const g = this.add.graphics({ x: 0, y: 0 });
    g.fillStyle(0xffffff, 1);
    const size = 90;
    if (left) {
      g.fillTriangle(0, size / 2, size, 0, size, size);
    } else {
      g.fillTriangle(0, 0, size, size / 2, 0, size);
    }
    g.generateTexture(key, size, size);
    g.destroy();
  }

  private makeLaneDashTexture() {
    const w = LANE_SEPARATOR_WIDTH,
      h = 64;
    const g = this.add.graphics({ x: 0, y: 0 });
    g.fillStyle(0xffffff, 1);
    g.fillRect(0, 0, w, 28);
    g.fillStyle(0x000000, 0);
    g.fillRect(0, 28, w, h - 28);
    g.generateTexture("laneDash", w, h);
    g.destroy();
  }

  // Grid helpers
  private getRowIndexForY(y: number) {
    return Math.round((y - this.gridOffsetY) / this.gridSizeY);
  }
  private getRowCenterY(rowIndex: number) {
    return this.gridOffsetY + rowIndex * this.gridSizeY;
  }

  // Check collision immediately when changing lanes to avoid timing exploits between ticks
  private checkImmediateCollisionAtLane(targetLane: number) {
    if (this.gameOver) return false;
    const playerRow = this.getRowIndexForY(this.playerY);
    const targetX = this.laneCenters[targetLane];
    for (const obj of this.obstacles.getChildren()) {
      const o = obj as Phaser.Physics.Arcade.Sprite;
      if (!o.active) continue;
      const ri = this.getRowIndexForY(o.y);
      if (ri === playerRow && Math.abs(o.x - targetX) < 2) {
        this.onCrash();
        return true;
      }
    }
    return false;
  }

  // Difficulty helpers
  private maybeIncreaseDifficulty() {
    // Level 0 -> 1 @ 15s: keep 2 gap ticks, reduce visible ticks to 6 (slightly faster)
    if (this.difficultyLevel < 1 && this.diffAccMs >= 15000) {
      this.difficultyLevel = 1;
      this.desiredTicksVisible = 6;
      this.recalcStepPixels();
      this.stripeSpeedFactor = 1.5;
    }
    // Level 1 -> 2 @ 30s: increase density by faster visuals (gap ticks auto-computed each spawn)
    if (this.difficultyLevel < 2 && this.diffAccMs >= 30000) {
      this.difficultyLevel = 2;
      this.stripeSpeedFactor = 1.6;
    }
    // Level 2 -> 3 @ 45s: reduce visible ticks to 5 (faster yet)
    if (this.difficultyLevel < 3 && this.diffAccMs >= 45000) {
      this.difficultyLevel = 3;
      this.desiredTicksVisible = 5;
      this.recalcStepPixels();
      this.stripeSpeedFactor = 1.7;
    }
    // Allow 2 cars per row earlier if player is performing well
    if (this.score >= 10) this.maxCarsPerRow = 2;
  }

  private recalcStepPixels() {
    const distanceToPlayer = this.playerY + 120; // from just above the screen to player level
    STEP_PIXELS = Math.max(24, Math.round(distanceToPlayer / this.desiredTicksVisible));
  }

  // Compute number of empty ticks between rows so that gap height ~= car display height
  private computeEqualGapTicks(displayH: number) {
    // Time between spawns in ticks is (gapTicks + 1)
    // Target: car band (~displayH) + gap band (~displayH * gapSafetyMultiplier)
    // So: (gapTicks + 1) * STEP_PIXELS ~= (1 + gapSafetyMultiplier) * displayH
    const pixelsBetweenSpawns = (1 + this.gapSafetyMultiplier) * displayH;
    const ticks = Math.max(1, Math.ceil(pixelsBetweenSpawns / STEP_PIXELS) - 1);
    return ticks;
  }
}
